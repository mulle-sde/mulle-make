#! /usr/bin/env bash
#
#   Copyright (c) 2015-2017 Nat! - Mulle kybernetiK
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#   Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
#   Neither the name of Mulle kybernetiK nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
MULLE_MAKE_COMMON_SH="included"


log_delete_all()
{
   sed d
   : # ensure true for pipe
}


log_grep_warning_error()
{
   #
   # error/warning grepper
   # try to grep and output warnings and errors generated by clang
   # ignore the rest
   #
   (
      local capture
      local line

      capture='NO'

      while IFS=$'\n' read -r line
      do
         case "${line}" in
            make:*|error:*|warning:*|*:[0-9]*:*error:*|*:[0-9]*:*warning:*|*undefined*reference*)
               capture='YES'
            ;;

            \ *|$'\t'*)
            ;;

            *)
               capture='NO'
            ;;
         esac

         if [ "${capture}" = 'NO' ]
         then
            continue
         fi

         printf "%s\n" "${line}"
      done
   )

   : # ensure true for pipe
}


#
# The configure plugin can't use nmake on mingw it must use mingw32-make
# (still called mingw32-make on 64 bit)
# The cmake plugin will use nmake though
#
mingw_bitness()
{
   uname | sed -e 's/MINGW\([0-9]*\)_.*/\1/'
}


tools_environment_common()
{
   log_entry "tools_environment_common" "$@"

   # no problem if those are empty
   if [ -z "${CC}" ]
   then
      CC="${DEFINITION_CC}"
   fi

   if [ -z "${CXX}" ]
   then
      CXX="${DEFINITION_CXX}"
   fi

   if [ "${MULLE_FLAG_LOG_VERBOSE}" = 'YES' ]
   then
      r_verify_binary "tr" "tr" "tr"
      TR="${RVAL}"
      r_verify_binary "sed" "sed" "sed"
      SED="${RVAL}"
      [ -z "${TR}" ]   && fail "can't locate tr"
      [ -z "${SED}" ]  && fail "can't locate sed"
   else
      TR=tr
      SED=sed
   fi
}


#
# no ninja here
#
r_platform_make()
{
   log_entry "r_platform_make" "$@"

   local compilerpath="$1"
   local plugin="$2"

   case "${MULLE_UNAME}" in
      windows)
         RVAL="nmake.exe"
      ;;

      mingw)
         case "${plugin}" in
            'configure')
               RVAL="mingw32-make"
            ;;

            *)
               local name

               r_basename "${compilerpath}"
               name="${RVAL}"
               case "${name%.*}" in
                  ""|cl|clang-cl|mulle-clang-cl)
                     RVAL="nmake"
                  ;;

                  *)
                     RVAL="mingw32-make"
                  ;;
               esac
            ;;
         esac
      ;;

      *)
         RVAL="make"
      ;;
   esac
}


# common functions for build tools

r_use_ninja_instead_of_make()
{
   log_entry "r_use_ninja_instead_of_make" "$@"

   #
   # Ninja is preferable if installed for cmake but not else
   #
   local extension

   # temporary fix, because MULLE_EXE_EXTENSION was lost during crafting
   # but I don't know why. If MULLE_UNAME is defined MULLE_EXE_EXTENSION
   # should be as well ?
   case "${MULLE_UNAME}" in
      windows)
         extension="${extension:-.exe}"
      ;;
   esac

   local ninjaexe
   local ninjaversion
   local flag

   flag="${DEFINITION_USE_NINJA:-YES}"
   case "${flag}" in
      'YES')
         ninjaexe="`command -v ninja${extension}`"
         if [ ! -z "${ninjaexe}" ]
         then
            ninjaversion="`"${ninjaexe}" --version`"
            case "${ninjaversion}" in
               0\.*|1\.[0]*|1\.10\.*)
               # less than 1.11 has problems with cleandead
               # https://github.com/ninja-build/ninja/pull/1996
                  if [ "${DEFINITION_USE_NINJA}" = 'YES' ]
                  then
                     log_warning "Ninja is too old (< 1.11.0) to use"
                  fi
                  RVAL=
                  return 1
               ;;

               *)
                  RVAL="ninja${extension}"
                  return 0
               ;;
            esac
         fi

         if [ "${DEFINITION_USE_NINJA}" = 'YES' ]
         then
            fail "ninja${extension} not found"
         fi
         log_debug "ninja${extension} not in PATH"
      ;;

      'NO')
         log_debug "Not searching for ninja"
      ;;

      *)
         internal_fail "DEFINITION_USE_NINJA contains garbage \"${DEFINITION_USE_NINJA}\""
      ;;
   esac

   RVAL=
   return 1
}


#
# sets the MAKE environment variable
#
r_make_for_plugin()
{
   log_entry "r_make_for_plugin" "$@"

   local plugin="$1"
   local no_ninja="$2"

   #
   # allow environment to override
   # (makes testing easier)
   #
   local make

   make="${DEFINITION_MAKE:-${MAKE}}"
   if [ -z "${make}" ]
   then
      r_platform_make "${DEFINITION_CC}" "${plugin}"
      make="${RVAL}"

      if [ -z "${no_ninja}" ]
      then
         if r_use_ninja_instead_of_make
         then
            make="${RVAL}"
         fi
      fi
   fi

   r_verify_binary "${make}" "make" "make"
}


#
# the shell escape will protect '$' as '\$'
# but that's not how make needs it. So we unprotect
# and then protect $$ as needed. So make can't mangle
# it.
#
r_escaped_make_string()
{
   local dollar='$'

   RVAL="$*"

   case "${RVAL}" in
      *\$*)
         RVAL="${RVAL//\\${dollar}/${dollar}}"            # unescape \$ -> $
         case "${RVAL}" in
            *\$[a-z0-9A-Z_%\'\#\?\*@{}-]*)
               RVAL="$( sed 's/$\([a-z0-9A-Z_%'"'"'#?*@{}-]\)/\$\\\1/g' <<< "${RVAL}" )"
            ;;
         esac
         RVAL="${RVAL//${dollar}${dollar}/${dollar}\\${dollar}}"  # escape $$ -> $\$
         RVAL="${RVAL//${dollar}/${dollar}${dollar}}"  # escape $ -> $$
      ;;
   esac
}

r_makeflags_add()
{
   local makeflags="$1"
   local value="$2"

   if [ -z "${value}" ]
   then
      RVAL="${makeflags}"
      return
   fi

   r_escaped_shell_string "${value}"
   r_concat "${makeflags}" "${RVAL}"
}


r_build_makefile()
{
   log_entry "r_build_makefile" "$@"

   local make="$1"
   local kitchendir="$2"

   local make_verbose_flags
   local cores

   cores="${OPTION_CORES}"

   case "${make}" in
      *ninja*)
         RVAL="${kitchendir}/build.ninja"
      ;;

      *make*)
         RVAL="${kitchendir}/Makefile"
      ;;
   esac
}


r_build_make_flags()
{
   log_entry "r_build_make_flags" "$@"

   local make="$1"
   local make_flags="$2"

   local make_verbose_flags
   local make_terse_flags
   local cores

   cores="${OPTION_CORES}"

   case "${make}" in
      *ninja*)
         make_verbose_flags="-v"
         if [ ! -z "${OPTION_LOAD}" ]
         then
            r_makeflags_add "${make_flags}" "-l"
            r_makeflags_add "${RVAL}" "${OPTION_LOAD}"
            make_flags="${RVAL}"
         fi
      ;;

      *nmake*)
         make_terse_flags="-s"
      ;;

      *make*)
         make_verbose_flags="VERBOSE=1"

         if [ -z "${cores}" ]
         then
            r_available_core_count
            cores="${RVAL}"
            log_fluff "Estimated available cores for make: ${cores}"
         fi
      ;;
   esac

   #
   # because the logging is done into files (usually), we don't really want
   # non-verbose output usually
   #
   if [ "${MULLE_FLAG_LOG_TERSE}" = 'YES' ]
   then
      r_makeflags_add "${make_flags}" "${make_terse_flags}"
      make_flags="${RVAL}"
   else
      r_makeflags_add "${make_flags}" "${make_verbose_flags}"
      make_flags="${RVAL}"
   fi

   if [ ! -z "${cores}" ]
   then
      r_makeflags_add "${make_flags}" "-j"
      r_makeflags_add "${RVAL}" "${cores}"
      make_flags="${RVAL}"
   fi

   RVAL="${make_flags}"
}



r_convert_file_to_cflag()
{
   local filepath="$1"
   local flag="$2"

   r_escaped_shell_string "${filepath}"
   r_escaped_make_string "${RVAL}"
   RVAL="${flag}${RVAL}"
}


r_convert_path_to_cflags()
{
   local filepath="$1"
   local flag="$2"

   local output

   RVAL=""

   IFS=':'
   shell_disable_glob
   for component in ${filepath}
   do
      shell_enable_glob

      r_convert_file_to_cflag "${component}" "${flag}"
      r_concat "${output}" "${RVAL}"
      output="${RVAL}"
   done
   IFS="${DEFAULT_IFS}"
   shell_enable_glob
}


r_sdkpath_tool_flags()
{
   log_entry "r_sdkpath_tool_flags" "$@"

   local sdk="$1"

   local sdkpath

   r_compiler_get_sdkpath "${sdk}"
   sdkpath="${RVAL}"

   if [ ! -z "${sdkpath}" ]
   then
      r_convert_file_to_cflag "${sdkpath}" "-isysroot "
      return 0
   fi 

   return 1
}


r_headerpath_preprocessor_flags()
{
   log_entry "r_headerpath_preprocessor_flags" "$@"

   local headersearchpaths
   local frameworksearchpaths

   case "${DEFINITION_CC}" in
      *clang*|*gcc)
         r_convert_path_to_cflags "${DEFINITION_INCLUDE_PATH}" "-isystem "
         headersearchpaths="${RVAL}"
      ;;

      *)
         r_convert_path_to_cflags "${DEFINITION_INCLUDE_PATH}" "-I"
         headersearchpaths="${RVAL}"
      ;;
   esac

   case "${MULLE_UNAME}" in
      darwin)
         r_convert_path_to_cflags "${DEFINITION_FRAMEWORKS_PATH}" "-F"
         frameworksearchpaths="${RVAL}"
      ;;
   esac

   if [ "${MULLE_FLAG_LOG_SETTINGS}" = 'YES' ]
   then
      log_trace2 "headersearchpaths:    ${headersearchpaths}"
      log_trace2 "frameworksearchpaths: ${frameworksearchpaths}"
   fi

   r_concat "${headersearchpaths}" "${frameworksearchpaths}"
}


r_librarypath_linker_flags()
{
   local librarysearchpaths
   local frameworksearchpaths

   r_convert_path_to_cflags "${DEFINITION_LIB_PATH}" "-L"
   librarysearchpaths="${RVAL}"

   case "${MULLE_UNAME}" in
      darwin)
         r_convert_path_to_cflags "${DEFINITION_FRAMEWORKS_PATH}" "-F"
         frameworksearchpaths="${RVAL}"
      ;;
   esac

   if [ "${MULLE_FLAG_LOG_SETTINGS}" = 'YES' ]
   then
      log_trace2 "librarysearchpaths:   ${librarysearchpaths}"
      log_trace2 "frameworksearchpaths: ${frameworksearchpaths}"
   fi

   r_concat "${librarysearchpaths}" "${frameworksearchpaths}"
}


_add_path_tool_cppflags()
{
   log_entry "__add_path_tool_flags" "$@"

   _add_sdk_path_tool_flags "$@"
   _add_header_and_library_path_tool_flags
}


build_fail()
{
   log_entry "build_fail" "$@"

   local logfile="$1"
   local command="$2"
   local rval="$3"
   local greplog="${4:-YES}"

   if [ "${greplog}" = 'YES' ] && [ -f "${logfile}" ]
   then
      printf "${C_RED}"
      egrep -B1 -A5 -w "[Ee]rror|FAILED:" "${logfile}" >&2
      printf "${C_RESET}"

      if [ "$MULLE_TRACE" != "1848" ]
      then
         # stupid bozo hack
         r_dirname "${logfile}" # remove file
         r_dirname "${RVAL}"    # remove .logs
         r_basename "${RVAL}"    # get project name
         # even worse bozo hack
         case "${RVAL}" in
            Release|Debug)
               RVAL=""
            ;;
         esac

         if [ ! -z "${MULLE_VIRTUAL_ROOT}" ]
         then
            local testprefix

            if [ ! -z "${MULLE_TEST}" ]
            then
               testprefix="test"
            fi

            log_info "See log with ${C_RESET_BOLD}mulle-sde ${testprefix}log ${RVAL} \
${C_INFO}(${logfile#${MULLE_USER_PWD}/})"
         fi
      fi
   fi

   case "$rval" in 
      127)
         if [ -z "${MULLE_VIRTUAL_ROOT}" ]
         then
            fail "${command} is apparently not in PATH."
         fi

         if [ -z `mudo command -v "${command}"` ]
         then
            fail "${command} is not installed in PATH."
         fi

         fail "${command} is not available.
${C_INFO}You may want to add it with
${C_RESET_BOLD}   mulle-sde tool --global add --optional ${command}"
      ;;

      *)
         fail "${command} failed with $rval"
      ;;
   esac
}


r_build_log_name()
{
   log_entry "r_build_log_name" "$@"

   local logsdir=$1
   local tool="$2"

   [ -z "${logsdir}" ] && internal_fail "logsdir missing"
   [ -z "${tool}" ]    && internal_fail "tool missing"

   r_absolutepath "${logsdir}"

   local countfile

   countfile="${logsdir}/.count"

   local count
   local logfile 
   
   count="`cat "${countfile}" 2> /dev/null`"
   count=${count:-0}

   while :
   do
      # if count exceeds 9 we get a sorting problem
      printf -v logfile "%s/%02d.%s.log" "${logsdir}" ${count} "${tool}"
      count=$(( $count + 1 ))

      if [ ! -f "${logfile}" ]
      then
         redirect_exekutor "${countfile}" printf "%s\n" "${count}"
         RVAL="${logfile}"
         return
      fi
   done
}


add_path_if_exists()
{
   local line="$1"
   local filepath="$2"

   if [ -e "${filepath}" ]
   then
      r_colon_concat "${line}" "${filepath}"
      line="${RVAL}"
   fi
   printf "%s\n" "${line}"
}


r_safe_tty()
{
   local tty

   TTY="`command -v tty`"
   if [ ! -z "${TTY}" ]
   then
      RVAL="`${TTY}`"
	   case "${RVAL}" in
	      *\ *) # not a tty or so
	         RVAL="/dev/stderr"
	      ;;
	   esac
   else
      RVAL="/dev/stderr"
   fi

   # can happen if sued to another user id
   if [ ! -w "${RVAL}" ]
   then
      log_warning "Can't write to console. Direct output unvailable, see logs."
   	RVAL="/dev/null"
   fi
}

#
# first find a project with matching name, otherwise find
# first nearest project
#
r_find_nearest_matching_pattern()
{
   log_entry "r_find_nearest_matching_pattern" "$@"

   local directory="$1"
   local pattern="$2"
   local expectation="$3"

   if [ ! -d "${directory}" ]
   then
      log_warning "\"${directory}\" not found"
      RVAL=""
      return 1
   fi

   local depth

   found=""
   depth=1000

   #     IFS='\0'

   local match1
   local match2
   local new_depth

   r_basename "${expectation}"
   match2="${RVAL}"

   #
   # don't go too deep in search
   #
   IFS=$'\n'
   for i in `rexekutor find -L "${directory}" -maxdepth 2 -name "${pattern}" -print`
   do
      IFS="${DEFAULT_IFS}"

      if [ "${i}" = "${expectation}" ]
      then
         log_fluff "\"${RVAL}\" found as complete match"
         RVAL="$i"
         return 0
      fi

      match1="${i##*/}"
      if [ "${match1}" = "${match2}" ]
      then
         RVAL="$i"
         log_fluff "\"${RVAL}\" found as matching filename "
         return 0
      fi

      r_path_depth "$i"
      new_depth="${RVAL}"

      if [ "${new_depth}" -lt "${depth}" ]
      then
         found="$i"
         depth="${new_depth}"
      fi
   done
   IFS="${DEFAULT_IFS}"

   if [ ! -z "${found}" ]
   then
      RVAL="${found#./}"
      log_debug "\"${RVAL}\" found as nearest match"
      return 0
   fi

   RVAL=""
   return 1
}


r_projectdir_relative_to_builddir()
{
   log_entry "r_projectdir_relative_to_builddir" "$@"

   local kitchendir="$1"
   local projectdir="$2"

   r_relative_path_between "${projectdir}" "${kitchendir}"
}



build_unix_flags()
{
   log_entry "build_unix_flags" "$@"

   _build_flags "$@"
}


make_common_initialize()
{
   if [ -z "${MULLE_STRING_SH}" ]
   then
      . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-string.sh" || return 1
   fi
   if [ -z "${MULLE_PATH_SH}" ]
   then
      . "${MULLE_BASHFUNCTIONS_LIBEXEC_DIR}/mulle-path.sh" || return 1
   fi
}

make_common_initialize

:
